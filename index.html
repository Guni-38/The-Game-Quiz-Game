<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>The Geme Quiz Game (TEST)</title>
<style>
  :root { --bg:#0b1020; --panel:#121a35; --accent:#36d1ff; --danger:#ff4560; --ok:#4cd964; --text:#e9f1ff; }
  * { box-sizing: border-box; }
  html,body { height:100%; }
  body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, 'Noto Sans JP', sans-serif; background:var(--bg); color:var(--text); overflow:hidden; }
  .wrap { display:grid; grid-template-rows: 16% 84%; height: 100dvh; max-height:100dvh; }
  header { background: linear-gradient(180deg, #111a33 0%, #0f1730 100%); padding:6px 8px; border-bottom:1px solid #22305d; }
  header .row { display:flex; gap:6px; align-items:center; flex-wrap:wrap; }
  header button { background:#1b2a57; border:1px solid #2c4490; color:#cfe7ff; padding:8px 12px; border-radius:12px; font-weight:700; cursor:pointer; font-size:14px; }
  header .stats { margin-left:auto; display:flex; gap:8px; align-items:center; }
  .pill { padding:6px 10px; border-radius:999px; background:#0f224b; border:1px solid #20408f; font-size:14px; }
  #lifePill.pulse { animation: lifePulse 1s ease-out; box-shadow:0 0 0 0 rgba(255,192,203,0.7); }
  @keyframes lifePulse { 0% { box-shadow:0 0 0 0 rgba(255,192,203,0.9); transform:scale(1); } 50% { box-shadow:0 0 24px 6px rgba(255,192,203,0.7); transform:scale(1.03); } 100% { box-shadow:0 0 0 0 rgba(255,192,203,0); transform:scale(1); } }
  .zone { display:grid; grid-template-rows:auto 1fr; gap:4px; height:100%; min-height:0; }
  .quiz { padding:6px 8px; background:#121a35; border-bottom:1px solid #20315f; min-height:0; }
  .q-text { font-size: clamp(12px, 1.6vw, 18px); line-height:1.28; font-weight:800; margin-bottom:6px; }
  .choices { display:grid; grid-template-columns:1fr 1fr; gap:4px; }
  .choice { background:#0f1b3b; border:1px solid #223b7a; padding:6px; border-radius:10px; min-height:36px; display:flex; gap:6px; align-items:center; }
  .badge { width:22px; height:22px; border-radius:6px; display:inline-grid; place-items:center; font-weight:900; font-size:12px; }
  .bA { background:#2b8aff; } .bB { background:#ff8a2b; } .bC { background:#4bc96f; } .bD { background:#d34bff; }
  .choice span { flex:1; font-size: clamp(12px, 1.6vw, 16px); }
  .playArea { position:relative; min-height:0; }
  canvas { display:block; width:100%; height:100%; background: radial-gradient(1200px 60% at 50% -10%, #19306b 0%, #071024 60%, #060a18 100%); touch-action:none; }
  .resultPanel { position:absolute; inset:auto 6px 6px 6px; margin:auto; width:min(96%, 600px); background:#0e1a3b; border:1px solid #2a3f7a; border-radius:16px; padding:14px; display:none; z-index:3; text-align:center; }
  .resultPanel.show { display:block; }
  .resultPanel h3 { margin:0 0 8px; font-size:22px; }
  .resultPanel p { margin:0 0 10px; font-size:16px; opacity:.9; }
  .resultPanel button { background:#1f7acb; border:1px solid #44aaff; color:#cfe7ff; padding:14px 18px; border-radius:12px; font-weight:900; font-size:18px; min-width:200px; }
  .flash { position:absolute; inset:0; background:rgba(255,0,0,0.28); pointer-events:none; opacity:0; transition:opacity .08s; z-index:4; }
  .flash.show { opacity:1; }
  .overlay { position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,.75); z-index:10; }
  .overlay.show { display:flex; }
  .card { background:#101a39; border:1px solid #2a3f7a; border-radius:20px; padding:24px; width:min(92%, 760px); text-align:center; box-shadow:0 10px 30px rgba(0,0,0,.5); }
  .card h1 { margin:0 0 8px; font-size:40px; letter-spacing:1px; }
  .card .big { font-size:52px; font-weight:900; margin:10px 0 0; color:#8ee6ff; }
  .card .sub { opacity:.9; margin:6px 0 0; font-size:16px; }
  .card button { margin-top:14px; background:#1f7acb; border:1px solid #44aaff; color:#cfe7ff; padding:12px 18px; border-radius:12px; font-weight:900; font-size:18px; }
  html, body, .wrap, .zone, .quiz, .choice, .playArea, canvas, .resultPanel, .overlay { -webkit-user-select:none; user-select:none; -webkit-touch-callout:none; -webkit-tap-highlight-color:transparent; }
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="row">
        <button id="startBtn">スタート</button>
        <div class="stats">
          <div class="pill">SCORE: <span id="score">0</span></div>
          <div class="pill" id="lifePill">LIFE: <span id="lives">❤❤❤</span></div>
          <div class="pill">Q <span id="qIndex">0</span>/<span id="qTotal">0</span></div>
        </div>
      </div>
    </header>

    <section class="zone">
      <div class="quiz">
        <div class="q-text" id="qText">内蔵サンプル or 同じフォルダの <b>quiz.csv</b> を自動読み込みします。スタートボタンで開始。</div>
        <div class="choices">
          <div class="choice"><div class="badge bA">A</div><span id="cA">—</span></div>
          <div class="choice"><div class="badge bB">B</div><span id="cB">—</span></div>
          <div class="choice"><div class="badge bC">C</div><span id="cC">—</span></div>
          <div class="choice"><div class="badge bD">D</div><span id="cD">—</span></div>
        </div>
      </div>
      <div class="playArea" id="play">
        <canvas id="game"></canvas>
        <div id="flash" class="flash"></div>
        <div id="resultPanel" class="resultPanel" role="button" aria-label="次の問題へ">
          <h3 id="resultTitle">結果</h3>
          <p id="resultDesc">—</p>
          <button id="nextBtn">次の問題へ</button>
        </div>
      </div>
    </section>
  </div>

  <div id="overlay" class="overlay">
    <div class="card" role="dialog" aria-modal="true">
      <h1 id="ovTitle">クリア！</h1>
      <div class="sub">最終スコア</div>
      <div id="ovScore" class="big">0</div>
      <div id="ovDetail" class="sub">—</div>
      <button id="retryBtn">もう一度</button>
    </div>
  </div>

<script>
  // ======= Elements & State =======
  const qText = document.getElementById('qText');
  const cA = document.getElementById('cA'), cB = document.getElementById('cB'), cC = document.getElementById('cC'), cD = document.getElementById('cD');
  const qIndexEl = document.getElementById('qIndex'), qTotalEl = document.getElementById('qTotal');
  const livesEl = document.getElementById('lives'), scoreEl = document.getElementById('score');
  const lifePill = document.getElementById('lifePill');
  const resultPanel = document.getElementById('resultPanel'), resultTitle = document.getElementById('resultTitle'), resultDesc = document.getElementById('resultDesc');
  const nextBtn = document.getElementById('nextBtn');
  const overlay = document.getElementById('overlay');
  const ovScore = document.getElementById('ovScore');
  const ovDetail = document.getElementById('ovDetail');
  const flash = document.getElementById('flash');

  // 仮想座標
  const VW = 360, VH = 640; let scale = 1, offX = 0, offY = 0, DPR = (window.devicePixelRatio||1);

  let questions = [], qi = 0, lives = 3, score = 0, awaitingConfirm = false, running=false;
  let invincibleUntil = 0, canRetryAt = 0, streak = 0;
  const MAX_LIVES = 3;

  // カウントダウン
  let roundFrozen = false, countdownStartMs = 0; const COUNTDOWN_MS = 3000;

  // 境界（枠線は常時／ラベルはスタート前のみ）
  const MOVE_MARGIN = { l:16, r:16, t:24, b:16 };
  function getMoveBounds(){ return { x: MOVE_MARGIN.l, y: MOVE_MARGIN.t, w: VW - MOVE_MARGIN.l - MOVE_MARGIN.r, h: VH - MOVE_MARGIN.t - MOVE_MARGIN.b }; }
  let showMoveHintPreGame = true;

  // アイテム
  let currentItem = null;      // 'fifty' | 'slow' | 'cure' | null
  let carryItemType = null;    // 未取得のまま次へ
  let slowFactor = 1;
  let effectMsgText = ''; let effectMsgUntil = 0;

  function setLives(n){ lives = Math.max(0, Math.min(MAX_LIVES, n)); const hearts='❤'.repeat(Math.max(0,lives)); livesEl.textContent = hearts||'0'; }
  function setScore(n){ score = n; scoreEl.textContent = score; }
  function addScore(delta){ setScore(score + delta); }

  function loadQuestion(i){
    if(!questions.length) return;
    if(i >= questions.length){ endGame(true); return; }
    qi = i;
    const q = questions[qi];

    // 選択肢ランダム入替
    const pairs = [{L:'A',txt:q.A},{L:'B',txt:q.B},{L:'C',txt:q.C},{L:'D',txt:q.D}];
    for(let j=pairs.length-1;j>0;j--){ const k=(Math.random()*(j+1))|0; [pairs[j],pairs[k]]=[pairs[k],pairs[j]]; }
    cA.textContent=pairs[0].txt; cB.textContent=pairs[1].txt; cC.textContent=pairs[2].txt; cD.textContent=pairs[3].txt;

    const origCorrect=(q.correct||'').toUpperCase(); const idx=pairs.findIndex(p=>p.L===origCorrect);
    q.correctShuffled=['A','B','C','D'][Math.max(0,idx)];

    qText.textContent = q.question;
    qIndexEl.textContent = (qi+1);
    qTotalEl.textContent = questions.length;
  }

  // ======= CSV auto-load =======
  function parseCSV(text){
    const lines = String(text).replace(/^\uFEFF/, '').split(/\r?\n/).filter(l => l.trim().length);
    const out = [];
    for(const l of lines){
      const parts = l.split(',');
      if(parts.length < 6) continue;
      const [question,A,B,C,D,correctRaw] = parts;
      const correct = (correctRaw||'').trim().toUpperCase().charAt(0);
      if('ABCD'.includes(correct)) out.push({question,A,B,C,D,correct});
    }
    return out;
  }

  const sampleCSV = `『スーパーマリオ』シリーズに登場するマリオの弟の名前はどれ？,ルイージ,ワリオ,ピーチ,ヨッシー,A
『MineCraft』では石炭または木炭と棒をクラフトして入手できる、漢字では「松明」と表記する道具はどれ？,たいまつ,ろうそく,くわ,つるはし,A
メインテーマ曲『英雄の証』は東京五輪2020の開会式でも使用された、CAPCOMが発売するハンティングアクションゲームシリーズはどれ？,モンスターハンター,ロックマン,ストリートファイター,デビルメイクライ,A
ゲームアプリ『パズル&ドラゴンズ』で、レアガチャ、スタミナ回復、モンスターBOXの拡張などに必要となる課金アイテムはどれ？,魔法石,オーブ,クリスタル,聖晶石,A
次の中で、『ポケットモンスター』シリーズで「はがねタイプ」に対して効果バツグンのダメージを与えられる技のタイプはどれ？,ほのおタイプ,みずタイプ,くさタイプ,でんきタイプ,A
『テトリス』に登場するブロックピース「テトリミノ」の形は全部で何種類？,7,6,5,8,A
『牧場物語』シリーズでは種が安価で生育が早いことから序盤でお世話になることが多い、春の七草の1つ「スズナ」としても知られる野菜はどれ？,カブ,ダイコン,ニンジン,キャベツ,A
『ドラゴンクエスト』シリーズでは敵に与える大ダメージの一撃の表現としておなじみの、「痛恨」の対義語はどれ？,会心,強烈,至高,絶好,A
『スペースインベーダー』で自陣に攻め込まれるギリギリの状態では敵の攻撃を受けないバグを利用した攻略テクニックの俗称はどれ？,名古屋撃ち,東京撃ち,大阪撃ち,福岡撃ち,A
『あつまれどうぶつの森』の「サカナ図鑑」に登録される生き物のうち唯一の両生類はどれ？,カエル,カメ,ザリガニ,サンショウウオ,A
『ペルソナ4』では主人公の最初のペルソナとなる、日本神話で日本の国と神々を生み出した男神はどなた？,イザナギ,カグツチ,ツクヨミ,スサノオ,A
ビデオゲームとして初めてのグッドデザイン賞を受賞したゲームソフトはどれ？,塊魂,リズム天国,パックマン,メイドインワリオ,A
『ひぐらしのなく頃に』のシナリオを手掛けたクリエイターの名前の由来でもある、『ファイナルファンタジー』シリーズに登場する槍とジャンプを得意とするジョブはどれ？,竜騎士,モンク,赤魔道士,風水士,A
2024年に『8番出口』の続編として配信開始されたゲームソフトのタイトルはどれ？,8番のりば,8番おりば,8番ホーム,8番階段,A
次の中で、NINTENDO64の発売と同時に発売されたゲームソフトの1つであるのはどれ？,最強羽生将棋,スターフォックス64,バンジョーとカズーイの大冒険,マリオパーティ,A`;

  async function autoLoadCSV(){
    const urlParam = new URLSearchParams(location.search).get('csv') || 'quiz.csv';
    try{
      const res = await fetch(urlParam, {cache:'no-store'});
      if(!res.ok) throw new Error('HTTP '+res.status);
      const txt = await res.text();
      const parsed = parseCSV(txt);
      if(!parsed.length) throw new Error('no rows');
      questions = parsed; qTotalEl.textContent = questions.length;
      qText.textContent = `問題データ（${urlParam}）を読み込みました。スタートボタンで開始します。`;
    }catch(e){
      questions = parseCSV(sampleCSV); qTotalEl.textContent = questions.length;
      qText.textContent = `内蔵サンプル問題を使用します。スタートボタンで開始します。`;
    }
  }

  // ======= Game (Virtual Coordinates) =======
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  let lastT=0;
  const ship = { x:VW/2, y:VH-40, w:28, h:28, speed:520 };
  const targets = []; // {type:'option'|'hazard'|'item', L?, kind?, x,y,w,h,vx,vy}
  const letters = ['A','B','C','D'];
  const colors = { A:'#2b8aff', B:'#ff8a2b', C:'#4bc96f', D:'#d34bff', H:'#7a7f87' };
  let pointer = {active:false,x:0,y:0};

  function resize(){
    const r = canvas.getBoundingClientRect();
    DPR = (window.devicePixelRatio||1);
    scale = Math.min(r.width / VW, r.height / VH);
    const cw = VW * scale, ch = VH * scale;
    offX = (r.width  - cw) / 2;
    offY = (r.height - ch) / 2;
    canvas.width  = Math.floor(r.width  * DPR);
    canvas.height = Math.floor(r.height * DPR);
    if(!running){ ship.x = VW/2; ship.y = VH - 40; }
  }
  new ResizeObserver(resize).observe(canvas);
  window.addEventListener('load', resize);
  window.addEventListener('orientationchange', resize);

  function toVirtual(clientX, clientY){
    const r = canvas.getBoundingClientRect();
    const x = (clientX - r.left - offX) / scale;
    const y = (clientY - r.top  - offY) / scale;
    return { x: Math.max(0, Math.min(VW, x)), y: Math.max(0, Math.min(VH, y)) };
  }

  function farFromShip(x,y,minDist){ const dx=x-ship.x, dy=y-ship.y; return (dx*dx+dy*dy) >= (minDist*minDist); }
  function nonOverlap(x,y,w,h,others,margin=10){ for(const o of others){ if(x < o.x+o.w+margin && x+w+margin > o.x && y < o.y+o.h+margin && y+h+margin > o.y) return false; } return true; }

  function pushMovingRect(arr, obj){
    const vx = (Math.random()<.5?-1:1)*(110+Math.random()*120);
    const vy = (Math.random()<.5?-1:1)*(90+Math.random()*110);
    arr.push({...obj, vx, vy});
  }

  function spawnItem(kind){
    const isz = 36; const maxTry=180; const minDist=140;
    let placed=false, tries=0;
    while(!placed && tries++<maxTry){
      const x = 12 + Math.random()*(VW - isz - 24);
      const y = 12 + Math.random()*(VH - isz - 160);
      if(!farFromShip(x+isz/2, y+isz/2, minDist)) continue;
      if(!nonOverlap(x,y,isz,isz,targets,14)) continue;
      pushMovingRect(targets, { type:'item', kind, x, y, w:isz, h:isz });
      placed=true; currentItem = kind;
    }
    if(!placed){ pushMovingRect(targets, { type:'item', kind, x: VW/2-18, y: 60, w:isz, h:isz }); currentItem = kind; }
  }

  function spawnTargets(){
    targets.length = 0;
    const maxTry = 200, size = 42;
    const minDist = 150;
    // A-D options
    for(let i=0;i<4;i++){
      const L = letters[i];
      let placed=false, tries=0;
      while(!placed && tries++<maxTry){
        const x = 12 + Math.random()*(VW - size - 24);
        const y = 12 + Math.random()*(VH - size - 160);
        if(!farFromShip(x+size/2, y+size/2, minDist)) continue;
        if(!nonOverlap(x,y,size,size,targets,14)) continue;
        pushMovingRect(targets, { type:'option', L, x, y, w:size, h:size });
        placed=true;
      }
      if(!placed){ pushMovingRect(targets, { type:'option', L, x:i*(size+12)+10, y:20, w:size, h:size }); }
    }

    // hazards: 5〜9問目は1個、10問目以降は2個
    const qnum = qi + 1;
    let hazardsToSpawn = (qnum >= 5 && qnum < 10) ? 1 : (qnum >= 10 ? 2 : 0);
    if(hazardsToSpawn > 0){
      const hzSize = 40; let count=0;
      while(count<hazardsToSpawn){
        let placed=false, tries=0;
        while(!placed && tries++<maxTry){
          const x = 12 + Math.random()*(VW - hzSize - 24);
          const y = 12 + Math.random()*(VH - hzSize - 160);
          if(!farFromShip(x+hzSize/2, y+hzSize/2, minDist*0.75)) continue;
          if(!nonOverlap(x,y,hzSize,hzSize,targets,14)) continue;
          pushMovingRect(targets, { type:'hazard', x, y, w:hzSize, h:hzSize });
          placed=true; count++;
        }
        if(!placed){ pushMovingRect(targets, { type:'hazard', x: 30+count*60, y: 40+count*40, w:hzSize, h:hzSize }); count++; }
      }
    }

    // item: 3問目以降 35%（同時出現1つ）。未取得なら持ち越し
    currentItem = null;
    const qnum2 = qi + 1;
    if(carryItemType){
      spawnItem(carryItemType);
      carryItemType = null;
    } else if(qnum2 >= 3 && Math.random() < 0.35){
      const kinds = ['fifty','slow','cure'];
      const kind = kinds[Math.floor(Math.random()*kinds.length)];
      spawnItem(kind);
    }
  }

  function rectRectHit(a,b){ return a.x<b.x+b.w && a.x+a.w>b.x && a.y<b.y+b.h && a.y+a.h>b.y; }

  function update(dt){
    if(!running) return;
    if(roundFrozen){ return; }

    if(pointer.active){
      const p = toVirtual(pointer.x, pointer.y);
      const dx = p.x - ship.x, dy = p.y - ship.y, len = Math.hypot(dx,dy);
      if(len>1){ ship.x += (dx/len)*ship.speed*dt; ship.y += (dy/len)*ship.speed*dt; }
      const bounds = getMoveBounds();
      ship.x = Math.max(bounds.x, Math.min(bounds.x + bounds.w, ship.x));
      ship.y = Math.max(bounds.y, Math.min(bounds.y + bounds.h, ship.y));
    }

    for(const t of targets){
      t.x += t.vx*dt*slowFactor; t.y += t.vy*dt*slowFactor;
      if(t.x < 8 || t.x+t.w > VW-8){ t.vx*=-1; t.x = Math.max(8, Math.min(VW-8-t.w, t.x)); }
      if(t.y < 8 || t.y+t.h > VH-28){ t.vy*=-1; t.y = Math.max(8, Math.min(VH-28-t.h, t.y)); }
    }

    const now = performance.now();
    if(now >= invincibleUntil){
      for(let i=0;i<targets.length;i++){
        const t = targets[i];
        if(rectRectHit({x:ship.x-10,y:ship.y-12,w:22,h:26}, t)){ onShipHit(t, i); break; }
      }
    }
  }

  function onShipHit(target, index){
    const q = questions[qi]; if(!q) return;

    // アイテム
    if(target.type==='item'){
      const itemIdx = targets.indexOf(target);
      if(itemIdx >= 0) targets.splice(itemIdx,1);
      currentItem = null;

      if(target.kind==='fifty'){
        // 正答 + 誤答1（or 正答のみ）
        const options = targets.filter(t=> t.type==='option');
        const correctLetter = (q && (q.correctShuffled||q.correct)) ? (q.correctShuffled||q.correct) : null;
        if(correctLetter){
          const wrongOptions = options.filter(t=> t.L !== correctLetter);
          let lettersToKeep = [correctLetter];
          if(wrongOptions.length >= 2){
            const keepWrong = wrongOptions[Math.floor(Math.random()*wrongOptions.length)].L;
            lettersToKeep.push(keepWrong);
          }
          for(let i=targets.length-1;i>=0;i--){
            const t = targets[i];
            if(t.type==='option' && !lettersToKeep.includes(t.L)){
              targets.splice(i,1);
            }
          }
        }
        showEffect('50:50 発動');
      } else if(target.kind==='slow'){
        slowFactor = 0.25; showEffect('SLOW 発動');
      } else if(target.kind==='cure'){
        if(lives < MAX_LIVES){ setLives(lives + 1); }
        if(lifePill){ lifePill.classList.add('pulse'); setTimeout(()=> lifePill.classList.remove('pulse'), 1000); }
        showEffect('CURE 発動');
      }
      return;
    }

    if(target.type==='hazard'){
      streak = 0;
      setLives(lives-1);
      if (typeof index === 'number' && index >= 0) { targets.splice(index, 1); }
      invincibleUntil = performance.now() + 900;
      flashOnce();
      if(lives<=0){ endGame(false); }
      return;
    }

    // 回答
    if(target.L === (q.correctShuffled || q.correct)){
      streak += 1;
      const bonus = Math.max(0, (streak-1) * 50);
      addScore(100 + bonus);
      awaitingConfirm = true;
      resultTitle.textContent = '正解！';
      resultDesc.textContent = (bonus>0) ? `100 + 連続ボーナス${bonus}点` : '100点';
      resultPanel.classList.add('show');
    } else {
      streak = 0;
      setLives(lives - 1);
      targets.splice(index, 1);
      invincibleUntil = performance.now() + 900;
      flashOnce();
      if(lives <= 0){ endGame(false); }
    }
  }

  function flashOnce(){ flash.classList.add('show'); setTimeout(()=> flash.classList.remove('show'), 110); }
  function showEffect(txt){ effectMsgText = txt; effectMsgUntil = performance.now() + 1400; }

  function draw(){
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,canvas.width,canvas.height);
    const s = scale * DPR;
    ctx.setTransform(s,0,0,s, offX*DPR, offY*DPR);

    // 背景（星）
    const w = VW, h = VH;
    ctx.globalAlpha = .25; ctx.fillStyle = '#bcdcff';
    for(let i=0;i<30;i++) ctx.fillRect((i*37%w),(i*73%h),2,2);
    ctx.globalAlpha = 1;

    // 移動可能エリア
    const b = getMoveBounds();
    ctx.save();
    ctx.lineWidth = 2; ctx.setLineDash([6,6]); ctx.strokeStyle = 'rgba(142,230,255,0.75)';
    ctx.strokeRect(b.x, b.y, b.w, b.h);
    ctx.setLineDash([]);
    if(!running && showMoveHintPreGame){
      ctx.font = 'bold 14px system-ui';
      ctx.fillStyle = 'rgba(200,230,255,0.9)';
      ctx.textAlign = 'center';
      ctx.fillText('この枠内を移動', b.x + b.w/2, b.y - 10);
    }
    ctx.restore();

    // ターゲット描画
    if (running) {
      ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.font='bold 16px system-ui';
      for(const t of targets){
        if(t.type==='hazard'){
          ctx.fillStyle = colors.H; ctx.fillRect(t.x,t.y,t.w,t.h);
          ctx.fillStyle = '#0b0f20'; ctx.fillText('■', t.x+t.w/2, t.y+t.h/2);
        } else if(t.type==='item'){
          ctx.beginPath();
          ctx.arc(t.x + t.w/2, t.y + t.h/2, Math.min(t.w,t.h)/2, 0, Math.PI*2);
          ctx.closePath();
          ctx.fillStyle = (t.kind==='fifty') ? '#ffe08a' : (t.kind==='slow' ? '#8ae0ff' : '#ffc0cb');
          ctx.fill();
          ctx.fillStyle = '#0b0f20';
          ctx.font = 'bold 14px system-ui';
          const label = (t.kind==='fifty') ? '50' : (t.kind==='slow' ? 'S' : '❤️');
          ctx.fillText(label, t.x+t.w/2, t.y+t.h/2);
          ctx.font = 'bold 16px system-ui';
        } else {
          ctx.fillStyle = colors[t.L]; ctx.fillRect(t.x,t.y,t.w,t.h);
          ctx.fillStyle = '#0b0f20'; ctx.fillText(t.L, t.x+t.w/2, t.y+t.h/2);
        }
      }
    }

    // 自機
    ctx.save(); ctx.translate(ship.x, ship.y);
    const now = performance.now();
    if(now < invincibleUntil && Math.floor(now/120)%2===0){ ctx.globalAlpha = 0.35; }
    ctx.fillStyle = '#a9d2ff';
    ctx.beginPath(); ctx.moveTo(0,-12); ctx.lineTo(12,12); ctx.lineTo(-12,12); ctx.closePath(); ctx.fill();
    ctx.globalAlpha = 1; ctx.restore();

    // 効果テキスト
    if(running && performance.now() < effectMsgUntil){
      ctx.save();
      ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.font='bold 18px system-ui';
      ctx.fillStyle='rgba(20,30,60,0.85)';
      const cx = VW/2, cy = 30; const wtxt = ctx.measureText(effectMsgText).width + 24;
      ctx.fillRect(cx - wtxt/2, cy-18, wtxt, 30);
      ctx.strokeStyle='#44aaff'; ctx.lineWidth=2; ctx.strokeRect(cx - wtxt/2, cy-18, wtxt, 30);
      ctx.fillStyle='#cfe7ff'; ctx.fillText(effectMsgText, cx, cy-3);
      ctx.restore();
    }

    // カウントダウン
    if(running && roundFrozen){
      const elapsed = performance.now() - countdownStartMs;
      const remain = COUNTDOWN_MS - elapsed;
      let text = '';
      if (remain > 2000) text = '3';
      else if (remain > 1000) text = '2';
      else if (remain > 0) text = '1';
      else if (remain > -500) text = 'START!';

      if (text) {
        ctx.save();
        ctx.textAlign='center'; ctx.textBaseline='middle';
        ctx.font = (text==='START!' ? 'bold 40px system-ui' : 'bold 56px system-ui');
        ctx.fillStyle = 'rgba(10,20,40,0.9)';
        const wtxt = ctx.measureText(text).width + 36;
        ctx.fillRect(VW/2 - wtxt/2, VH/2 - 34, wtxt, 68);
        ctx.strokeStyle = '#44aaff'; ctx.lineWidth = 3; ctx.strokeRect(VW/2 - wtxt/2, VH/2 - 34, wtxt, 68);
        ctx.fillStyle = '#cfe7ff';
        ctx.fillText(text, VW/2, VH/2 + 4);
        ctx.restore();
      }
      if (remain <= -500) { roundFrozen = false; invincibleUntil = performance.now() + 900; }
    }
  }

  function loop(ts){ const dt = Math.min(.033,(ts-lastT)/1000||0); lastT = ts; if(running && !awaitingConfirm) update(dt); draw(); requestAnimationFrame(loop); }
  requestAnimationFrame(loop);

  function proceedNext(){
    const leftover = targets.find(t=>t.type==='item');
    carryItemType = leftover ? leftover.kind : null;
    resultPanel.classList.remove('show'); awaitingConfirm=false; loadQuestion(qi+1); startRoundWithCountdown();
  }
  nextBtn.addEventListener('click', (e)=>{ e.preventDefault(); proceedNext(); });
  resultPanel.addEventListener('click', ()=>{ if(resultPanel.classList.contains('show')) proceedNext(); });
  document.addEventListener('pointerdown', ()=>{ if(resultPanel.classList.contains('show')) proceedNext(); }, {passive:true});

  function startRoundWithCountdown(){ slowFactor = 1; spawnTargets(); roundFrozen = true; countdownStartMs = performance.now(); }

  function startGame(){
    if(!questions.length){ return; }
    targets.length = 0; carryItemType = null; currentItem = null; slowFactor = 1;
    effectMsgText = ''; effectMsgUntil = 0; setScore(0); setLives(3); streak=0;
    loadQuestion(0);
    const prevRunning = running; running = false; draw(); running = prevRunning; // 残像クリア
    running = true; showMoveHintPreGame = false; startRoundWithCountdown();
  }

  function endGame(cleared){
    running=false; awaitingConfirm=false;
    targets.length = 0; currentItem = null; carryItemType = null; slowFactor = 1;
    effectMsgText = ''; effectMsgUntil = 0; roundFrozen = false;
    canRetryAt = performance.now() + 800;
    overlay.classList.add('show');
    document.getElementById('ovTitle').textContent = cleared ? 'クリア！' : 'ゲームオーバー';
    ovScore.textContent = String(score);
    ovDetail.textContent = cleared ? 'お見事！全問突破しました。' : 'また挑戦してね。';
  }

  document.getElementById('startBtn').addEventListener('click', ()=>{ if(!running){ startGame(); }});
  document.getElementById('retryBtn').addEventListener('click', (e)=>{
    e.stopPropagation();
    if(performance.now() < canRetryAt) return;
    overlay.classList.remove('show');
    startGame();
  });

  // Controls
  canvas.addEventListener('pointerdown', e=>{ pointer.active=true; pointer.x=e.clientX; pointer.y=e.clientY; });
  canvas.addEventListener('pointermove', e=>{ if(pointer.active){ pointer.x=e.clientX; pointer.y=e.clientY; } });
  window.addEventListener('pointerup', ()=>{ pointer.active=false; });

  // Keyboard
  window.addEventListener('keydown', e=>{ if(e.key==='Enter' && resultPanel.classList.contains('show')) proceedNext(); });

  // Self tests
  (function runTests(){
    console.assert(parseCSV(`Q1,A,B,C,D,A\nQ2,a,b,c,d,B`).length===2, 'parseCSV: unix');
    console.assert(parseCSV(`Q1,A,B,C,D,A\r\nQ2,a,b,c,d,B\r\n`).length===2, 'parseCSV: win');
    console.assert(parseCSV(`\uFEFFQ1,A,B,C,D,A`).length===1, 'parseCSV: BOM');
    qi = 4; spawnTargets(); console.assert(targets.filter(t=>t.type==='hazard').length===1, 'hazard: 1 at Q5');
    qi = 9; spawnTargets(); console.assert(targets.filter(t=>t.type==='hazard').length===2, 'hazard: 2 at Q10');
    questions = [{question:'q',A:'a',B:'b',C:'c',D:'d',correct:'B'}]; qi = 0;
    targets.length=0;
    targets.push(
      {type:'option',L:'A',x:0,y:0,w:10,h:10},
      {type:'option',L:'B',x:0,y:0,w:10,h:10},
      {type:'option',L:'C',x:0,y:0,w:10,h:10},
      {type:'option',L:'D',x:0,y:0,w:10,h:10},
      {type:'item',kind:'fifty',x:0,y:0,w:10,h:10}
    );
    onShipHit(targets[4],4);
    let opts = targets.filter(t=>t.type==='option');
    console.assert(opts.length===2 && opts.some(o=>o.L==='B') && opts.some(o=>o.L!=='B'), '50:50 keeps correct + one wrong');
    targets.length=0;
    targets.push(
      {type:'option',L:'B',x:0,y:0,w:10,h:10},
      {type:'option',L:'A',x:0,y:0,w:10,h:10},
      {type:'item',kind:'fifty',x:0,y:0,w:10,h:10}
    );
    onShipHit(targets[2],2);
    opts = targets.filter(t=>t.type==='option');
    console.assert(opts.length===1 && opts[0].L==='B', '50:50 leaves only correct when only one wrong existed');
  })();

  // Boot
  window.addEventListener('contextmenu', e=> e.preventDefault());
  document.addEventListener('selectstart', e=> e.preventDefault());
  document.addEventListener('gesturestart', e=> e.preventDefault());
  autoLoadCSV();
</script>
</body>
</html>
